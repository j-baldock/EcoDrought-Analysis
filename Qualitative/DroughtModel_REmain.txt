model {

##--- LIKELIHOOD ---------------------------------------------------##

for (i in 1:nObs) {

  D[i] ~ dnorm(mu[i], pow(sigma[i], -2))
  mu[i] <- alpha[basins[i]] + beta[basins[i]] * W[i]
  log(sigma[i]) <- sig.alpha + sig.beta * W[i]
  
  # Log-likelihood
  loglik[i] <- logdensity.norm(D[i], mu[i], pow(sigma[i], -2))
  }


##--- RANDOM EFFECTS ------------------------------------------------##

for (j in numBasins) {
    alpha[j] ~ dnorm(mu.alpha, pow(sigma.alpha, -2)) 
    beta[j] ~ dnorm(mu.beta, pow(sigma.beta, -2))
}
    

##--- PRIORS --------------------------------------------------------##

mu.alpha ~ dnorm(0, pow(10, -2))
mu.beta ~ dnorm(0, pow(10, -2))

sigma.alpha ~ dunif(0, 100)
sigma.beta ~ dunif(0, 100)

sig.alpha ~ dnorm(0, pow(10, -2))
sig.beta ~ dnorm(0, pow(10, -2))


##--- DERIVED VALUES ------------------------------------------------##

# attenuation strength
AS <- exp(sig.alpha + sig.beta * 0) / exp(sig.alpha + sig.beta * 100)

# prediction means
for (i in 1:nPreds) {
    P0m[i] <- mu.alpha + mu.beta * Wp[i]
    P1m[i] <- alpha[1] + beta[1] * Wp[i]
    P3m[i] <- alpha[3] + beta[3] * Wp[i]
    P5m[i] <- alpha[5] + beta[5] * Wp[i]
    P6m[i] <- alpha[6] + beta[6] * Wp[i]
    P7m[i] <- alpha[7] + beta[7] * Wp[i]
    P8m[i] <- alpha[8] + beta[8] * Wp[i]
}

# prediction intervals
for (i in 1:nPreds) {
    P0i[i] ~ dnorm(mu.alpha + mu.beta * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P1i[i] ~ dnorm(alpha[1] + beta[1] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P3i[i] ~ dnorm(alpha[3] + beta[3] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P5i[i] ~ dnorm(alpha[5] + beta[5] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P6i[i] ~ dnorm(alpha[6] + beta[6] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P7i[i] ~ dnorm(alpha[7] + beta[7] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
    P8i[i] ~ dnorm(alpha[8] + beta[8] * Wp[i], pow(exp(sig.alpha + sig.beta * Wp[i]), -2))
}

# sigma means
for (i in 1:nPreds) { S0m[i] <- exp(sig.alpha + sig.beta * Wp[i]) }

}